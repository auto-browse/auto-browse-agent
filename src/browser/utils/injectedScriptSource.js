
// This file is auto-generated. Do not edit.
export const injectedScriptSource = "\"use strict\";\nvar InjectedScriptExports = (() => {\n  var __defProp = Object.defineProperty;\n  var __getOwnPropDesc = Object.getOwnPropertyDescriptor;\n  var __getOwnPropNames = Object.getOwnPropertyNames;\n  var __hasOwnProp = Object.prototype.hasOwnProperty;\n  var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\n  var __export = (target, all) => {\n    for (var name in all)\n      __defProp(target, name, { get: all[name], enumerable: true });\n  };\n  var __copyProps = (to, from, except, desc) => {\n    if (from && typeof from === \"object\" || typeof from === \"function\") {\n      for (let key of __getOwnPropNames(from))\n        if (!__hasOwnProp.call(to, key) && key !== except)\n          __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });\n    }\n    return to;\n  };\n  var __toCommonJS = (mod) => __copyProps(__defProp({}, \"__esModule\", { value: true }), mod);\n  var __publicField = (obj, key, value) => __defNormalProp(obj, typeof key !== \"symbol\" ? key + \"\" : key, value);\n\n  // src/browser/snapshot/injectedScript.ts\n  var injectedScript_exports = {};\n  __export(injectedScript_exports, {\n    InjectedScript: () => InjectedScript,\n    createAriaSnapshot: () => createAriaSnapshot\n  });\n\n  // src/browser/snapshot/isomorphic/builtins.ts\n  function builtins(global) {\n    var _a, _b, _c, _d, _e, _f, _g, _h, _i;\n    global = global != null ? global : globalThis;\n    if (!global[\"__playwright_builtins__\"]) {\n      const builtins2 = {\n        setTimeout: (_a = global.setTimeout) == null ? void 0 : _a.bind(global),\n        clearTimeout: (_b = global.clearTimeout) == null ? void 0 : _b.bind(global),\n        setInterval: (_c = global.setInterval) == null ? void 0 : _c.bind(global),\n        clearInterval: (_d = global.clearInterval) == null ? void 0 : _d.bind(global),\n        requestAnimationFrame: (_e = global.requestAnimationFrame) == null ? void 0 : _e.bind(global),\n        cancelAnimationFrame: (_f = global.cancelAnimationFrame) == null ? void 0 : _f.bind(global),\n        requestIdleCallback: (_g = global.requestIdleCallback) == null ? void 0 : _g.bind(global),\n        cancelIdleCallback: (_h = global.cancelIdleCallback) == null ? void 0 : _h.bind(global),\n        performance: global.performance,\n        eval: (_i = global.eval) == null ? void 0 : _i.bind(global),\n        Intl: global.Intl,\n        Date: global.Date,\n        Map: global.Map,\n        Set: global.Set\n      };\n      Object.defineProperty(global, \"__playwright_builtins__\", { value: builtins2, configurable: false, enumerable: false, writable: false });\n    }\n    return global[\"__playwright_builtins__\"];\n  }\n  var instance = builtins();\n  var setTimeout = instance.setTimeout;\n  var clearTimeout = instance.clearTimeout;\n  var setInterval = instance.setInterval;\n  var clearInterval = instance.clearInterval;\n  var requestAnimationFrame = instance.requestAnimationFrame;\n  var cancelAnimationFrame = instance.cancelAnimationFrame;\n  var requestIdleCallback = instance.requestIdleCallback;\n  var cancelIdleCallback = instance.cancelIdleCallback;\n  var performance = instance.performance;\n  var Intl = instance.Intl;\n  var Date = instance.Date;\n  var Map = instance.Map;\n  var Set = instance.Set;\n\n  // src/browser/snapshot/isomorphic/stringUtils.ts\n  var normalizedWhitespaceCache;\n  function normalizeWhiteSpace(text) {\n    let result = normalizedWhitespaceCache == null ? void 0 : normalizedWhitespaceCache.get(text);\n    if (result === void 0) {\n      result = text.replace(/[\\u200b\\u00ad]/g, \"\").trim().replace(/\\s+/g, \" \");\n      normalizedWhitespaceCache == null ? void 0 : normalizedWhitespaceCache.set(text, result);\n    }\n    return result;\n  }\n  function escapeRegExp(s) {\n    return s.replace(/[.*+?^${}()|[\\]\\\\]/g, \"\\\\$&\");\n  }\n  function longestCommonSubstring(s1, s2) {\n    const n = s1.length;\n    const m = s2.length;\n    let maxLen = 0;\n    let endingIndex = 0;\n    const dp = Array(n + 1).fill(null).map(() => Array(m + 1).fill(0));\n    for (let i = 1; i <= n; i++) {\n      for (let j = 1; j <= m; j++) {\n        if (s1[i - 1] === s2[j - 1]) {\n          dp[i][j] = dp[i - 1][j - 1] + 1;\n          if (dp[i][j] > maxLen) {\n            maxLen = dp[i][j];\n            endingIndex = i;\n          }\n        }\n      }\n    }\n    return s1.slice(endingIndex - maxLen, endingIndex);\n  }\n\n  // src/browser/snapshot/domUtils.ts\n  var globalOptions = {};\n  function getGlobalOptions() {\n    return globalOptions;\n  }\n  function parentElementOrShadowHost(element) {\n    if (element.parentElement)\n      return element.parentElement;\n    if (!element.parentNode)\n      return;\n    if (element.parentNode.nodeType === 11 && element.parentNode.host)\n      return element.parentNode.host;\n  }\n  function enclosingShadowRootOrDocument(element) {\n    let node = element;\n    while (node.parentNode)\n      node = node.parentNode;\n    if (node.nodeType === 11 || node.nodeType === 9)\n      return node;\n  }\n  function enclosingShadowHost(element) {\n    while (element.parentElement)\n      element = element.parentElement;\n    return parentElementOrShadowHost(element);\n  }\n  function closestCrossShadow(element, css, scope) {\n    while (element) {\n      const closest = element.closest(css);\n      if (scope && closest !== scope && (closest == null ? void 0 : closest.contains(scope)))\n        return;\n      if (closest)\n        return closest;\n      element = enclosingShadowHost(element);\n    }\n  }\n  function getElementComputedStyle(element, pseudo) {\n    return element.ownerDocument && element.ownerDocument.defaultView ? element.ownerDocument.defaultView.getComputedStyle(element, pseudo) : void 0;\n  }\n  function isElementStyleVisibilityVisible(element, style) {\n    style = style != null ? style : getElementComputedStyle(element);\n    if (!style)\n      return true;\n    if (Element.prototype.checkVisibility && globalOptions.browserNameForWorkarounds !== \"webkit\") {\n      if (!element.checkVisibility())\n        return false;\n    } else {\n      const detailsOrSummary = element.closest(\"details,summary\");\n      if (detailsOrSummary !== element && (detailsOrSummary == null ? void 0 : detailsOrSummary.nodeName) === \"DETAILS\" && !detailsOrSummary.open)\n        return false;\n    }\n    if (style.visibility !== \"visible\")\n      return false;\n    return true;\n  }\n  function isVisibleTextNode(node) {\n    const range = node.ownerDocument.createRange();\n    range.selectNode(node);\n    const rect = range.getBoundingClientRect();\n    return rect.width > 0 && rect.height > 0;\n  }\n  function elementSafeTagName(element) {\n    if (element instanceof HTMLFormElement)\n      return \"FORM\";\n    return element.tagName.toUpperCase();\n  }\n\n  // src/browser/snapshot/roleUtils.ts\n  function hasExplicitAccessibleName(e) {\n    return e.hasAttribute(\"aria-label\") || e.hasAttribute(\"aria-labelledby\");\n  }\n  var kAncestorPreventingLandmark = \"article:not([role]), aside:not([role]), main:not([role]), nav:not([role]), section:not([role]), [role=article], [role=complementary], [role=main], [role=navigation], [role=region]\";\n  var kGlobalAriaAttributes = [\n    [\"aria-atomic\", void 0],\n    [\"aria-busy\", void 0],\n    [\"aria-controls\", void 0],\n    [\"aria-current\", void 0],\n    [\"aria-describedby\", void 0],\n    [\"aria-details\", void 0],\n    // Global use deprecated in ARIA 1.2\n    // ['aria-disabled', undefined],\n    [\"aria-dropeffect\", void 0],\n    // Global use deprecated in ARIA 1.2\n    // ['aria-errormessage', undefined],\n    [\"aria-flowto\", void 0],\n    [\"aria-grabbed\", void 0],\n    // Global use deprecated in ARIA 1.2\n    // ['aria-haspopup', undefined],\n    [\"aria-hidden\", void 0],\n    // Global use deprecated in ARIA 1.2\n    // ['aria-invalid', undefined],\n    [\"aria-keyshortcuts\", void 0],\n    [\"aria-label\", [\"caption\", \"code\", \"deletion\", \"emphasis\", \"generic\", \"insertion\", \"paragraph\", \"presentation\", \"strong\", \"subscript\", \"superscript\"]],\n    [\"aria-labelledby\", [\"caption\", \"code\", \"deletion\", \"emphasis\", \"generic\", \"insertion\", \"paragraph\", \"presentation\", \"strong\", \"subscript\", \"superscript\"]],\n    [\"aria-live\", void 0],\n    [\"aria-owns\", void 0],\n    [\"aria-relevant\", void 0],\n    [\"aria-roledescription\", [\"generic\"]]\n  ];\n  function hasGlobalAriaAttribute(element, forRole) {\n    return kGlobalAriaAttributes.some(([attr, prohibited]) => {\n      return !(prohibited == null ? void 0 : prohibited.includes(forRole || \"\")) && element.hasAttribute(attr);\n    });\n  }\n  function hasTabIndex(element) {\n    return !Number.isNaN(Number(String(element.getAttribute(\"tabindex\"))));\n  }\n  function isFocusable(element) {\n    return !isNativelyDisabled(element) && (isNativelyFocusable(element) || hasTabIndex(element));\n  }\n  function isNativelyFocusable(element) {\n    const tagName = elementSafeTagName(element);\n    if ([\"BUTTON\", \"DETAILS\", \"SELECT\", \"TEXTAREA\"].includes(tagName))\n      return true;\n    if (tagName === \"A\" || tagName === \"AREA\")\n      return element.hasAttribute(\"href\");\n    if (tagName === \"INPUT\")\n      return !element.hidden;\n    return false;\n  }\n  var kImplicitRoleByTagName = {\n    \"A\": (e) => {\n      return e.hasAttribute(\"href\") ? \"link\" : null;\n    },\n    \"AREA\": (e) => {\n      return e.hasAttribute(\"href\") ? \"link\" : null;\n    },\n    \"ARTICLE\": () => \"article\",\n    \"ASIDE\": () => \"complementary\",\n    \"BLOCKQUOTE\": () => \"blockquote\",\n    \"BUTTON\": () => \"button\",\n    \"CAPTION\": () => \"caption\",\n    \"CODE\": () => \"code\",\n    \"DATALIST\": () => \"listbox\",\n    \"DD\": () => \"definition\",\n    \"DEL\": () => \"deletion\",\n    \"DETAILS\": () => \"group\",\n    \"DFN\": () => \"term\",\n    \"DIALOG\": () => \"dialog\",\n    \"DT\": () => \"term\",\n    \"EM\": () => \"emphasis\",\n    \"FIELDSET\": () => \"group\",\n    \"FIGURE\": () => \"figure\",\n    \"FOOTER\": (e) => closestCrossShadow(e, kAncestorPreventingLandmark) ? null : \"contentinfo\",\n    \"FORM\": (e) => hasExplicitAccessibleName(e) ? \"form\" : null,\n    \"H1\": () => \"heading\",\n    \"H2\": () => \"heading\",\n    \"H3\": () => \"heading\",\n    \"H4\": () => \"heading\",\n    \"H5\": () => \"heading\",\n    \"H6\": () => \"heading\",\n    \"HEADER\": (e) => closestCrossShadow(e, kAncestorPreventingLandmark) ? null : \"banner\",\n    \"HR\": () => \"separator\",\n    \"HTML\": () => \"document\",\n    \"IMG\": (e) => e.getAttribute(\"alt\") === \"\" && !e.getAttribute(\"title\") && !hasGlobalAriaAttribute(e) && !hasTabIndex(e) ? \"presentation\" : \"img\",\n    \"INPUT\": (e) => {\n      const type = e.type.toLowerCase();\n      if (type === \"search\")\n        return e.hasAttribute(\"list\") ? \"combobox\" : \"searchbox\";\n      if ([\"email\", \"tel\", \"text\", \"url\", \"\"].includes(type)) {\n        const list = getIdRefs(e, e.getAttribute(\"list\"))[0];\n        return list && elementSafeTagName(list) === \"DATALIST\" ? \"combobox\" : \"textbox\";\n      }\n      if (type === \"hidden\")\n        return null;\n      if (type === \"file\" && !getGlobalOptions().inputFileRoleTextbox)\n        return \"button\";\n      return inputTypeToRole[type] || \"textbox\";\n    },\n    \"INS\": () => \"insertion\",\n    \"LI\": () => \"listitem\",\n    \"MAIN\": () => \"main\",\n    \"MARK\": () => \"mark\",\n    \"MATH\": () => \"math\",\n    \"MENU\": () => \"list\",\n    \"METER\": () => \"meter\",\n    \"NAV\": () => \"navigation\",\n    \"OL\": () => \"list\",\n    \"OPTGROUP\": () => \"group\",\n    \"OPTION\": () => \"option\",\n    \"OUTPUT\": () => \"status\",\n    \"P\": () => \"paragraph\",\n    \"PROGRESS\": () => \"progressbar\",\n    \"SECTION\": (e) => hasExplicitAccessibleName(e) ? \"region\" : null,\n    \"SELECT\": (e) => e.hasAttribute(\"multiple\") || e.size > 1 ? \"listbox\" : \"combobox\",\n    \"STRONG\": () => \"strong\",\n    \"SUB\": () => \"subscript\",\n    \"SUP\": () => \"superscript\",\n    // For <svg> we default to Chrome behavior:\n    // - Chrome reports 'img'.\n    // - Firefox reports 'diagram' that is not in official ARIA spec yet.\n    // - Safari reports 'no role', but still computes accessible name.\n    \"SVG\": () => \"img\",\n    \"TABLE\": () => \"table\",\n    \"TBODY\": () => \"rowgroup\",\n    \"TD\": (e) => {\n      const table = closestCrossShadow(e, \"table\");\n      const role = table ? getExplicitAriaRole(table) : \"\";\n      return role === \"grid\" || role === \"treegrid\" ? \"gridcell\" : \"cell\";\n    },\n    \"TEXTAREA\": () => \"textbox\",\n    \"TFOOT\": () => \"rowgroup\",\n    \"TH\": (e) => {\n      if (e.getAttribute(\"scope\") === \"col\")\n        return \"columnheader\";\n      if (e.getAttribute(\"scope\") === \"row\")\n        return \"rowheader\";\n      const table = closestCrossShadow(e, \"table\");\n      const role = table ? getExplicitAriaRole(table) : \"\";\n      return role === \"grid\" || role === \"treegrid\" ? \"gridcell\" : \"cell\";\n    },\n    \"THEAD\": () => \"rowgroup\",\n    \"TIME\": () => \"time\",\n    \"TR\": () => \"row\",\n    \"UL\": () => \"list\"\n  };\n  var kPresentationInheritanceParents = {\n    \"DD\": [\"DL\", \"DIV\"],\n    \"DIV\": [\"DL\"],\n    \"DT\": [\"DL\", \"DIV\"],\n    \"LI\": [\"OL\", \"UL\"],\n    \"TBODY\": [\"TABLE\"],\n    \"TD\": [\"TR\"],\n    \"TFOOT\": [\"TABLE\"],\n    \"TH\": [\"TR\"],\n    \"THEAD\": [\"TABLE\"],\n    \"TR\": [\"THEAD\", \"TBODY\", \"TFOOT\", \"TABLE\"]\n  };\n  function getImplicitAriaRole(element) {\n    var _a;\n    const implicitRole = ((_a = kImplicitRoleByTagName[elementSafeTagName(element)]) == null ? void 0 : _a.call(kImplicitRoleByTagName, element)) || \"\";\n    if (!implicitRole)\n      return null;\n    let ancestor = element;\n    while (ancestor) {\n      const parent = parentElementOrShadowHost(ancestor);\n      const parents = kPresentationInheritanceParents[elementSafeTagName(ancestor)];\n      if (!parents || !parent || !parents.includes(elementSafeTagName(parent)))\n        break;\n      const parentExplicitRole = getExplicitAriaRole(parent);\n      if ((parentExplicitRole === \"none\" || parentExplicitRole === \"presentation\") && !hasPresentationConflictResolution(parent, parentExplicitRole))\n        return parentExplicitRole;\n      ancestor = parent;\n    }\n    return implicitRole;\n  }\n  var validRoles = [\n    \"alert\",\n    \"alertdialog\",\n    \"application\",\n    \"article\",\n    \"banner\",\n    \"blockquote\",\n    \"button\",\n    \"caption\",\n    \"cell\",\n    \"checkbox\",\n    \"code\",\n    \"columnheader\",\n    \"combobox\",\n    \"complementary\",\n    \"contentinfo\",\n    \"definition\",\n    \"deletion\",\n    \"dialog\",\n    \"directory\",\n    \"document\",\n    \"emphasis\",\n    \"feed\",\n    \"figure\",\n    \"form\",\n    \"generic\",\n    \"grid\",\n    \"gridcell\",\n    \"group\",\n    \"heading\",\n    \"img\",\n    \"insertion\",\n    \"link\",\n    \"list\",\n    \"listbox\",\n    \"listitem\",\n    \"log\",\n    \"main\",\n    \"mark\",\n    \"marquee\",\n    \"math\",\n    \"meter\",\n    \"menu\",\n    \"menubar\",\n    \"menuitem\",\n    \"menuitemcheckbox\",\n    \"menuitemradio\",\n    \"navigation\",\n    \"none\",\n    \"note\",\n    \"option\",\n    \"paragraph\",\n    \"presentation\",\n    \"progressbar\",\n    \"radio\",\n    \"radiogroup\",\n    \"region\",\n    \"row\",\n    \"rowgroup\",\n    \"rowheader\",\n    \"scrollbar\",\n    \"search\",\n    \"searchbox\",\n    \"separator\",\n    \"slider\",\n    \"spinbutton\",\n    \"status\",\n    \"strong\",\n    \"subscript\",\n    \"superscript\",\n    \"switch\",\n    \"tab\",\n    \"table\",\n    \"tablist\",\n    \"tabpanel\",\n    \"term\",\n    \"textbox\",\n    \"time\",\n    \"timer\",\n    \"toolbar\",\n    \"tooltip\",\n    \"tree\",\n    \"treegrid\",\n    \"treeitem\"\n  ];\n  function getExplicitAriaRole(element) {\n    const roles = (element.getAttribute(\"role\") || \"\").split(\" \").map((role) => role.trim());\n    return roles.find((role) => validRoles.includes(role)) || null;\n  }\n  function hasPresentationConflictResolution(element, role) {\n    return hasGlobalAriaAttribute(element, role) || isFocusable(element);\n  }\n  function getAriaRole(element) {\n    const explicitRole = getExplicitAriaRole(element);\n    if (!explicitRole)\n      return getImplicitAriaRole(element);\n    if (explicitRole === \"none\" || explicitRole === \"presentation\") {\n      const implicitRole = getImplicitAriaRole(element);\n      if (hasPresentationConflictResolution(element, implicitRole))\n        return implicitRole;\n    }\n    return explicitRole;\n  }\n  function getAriaBoolean(attr) {\n    return attr === null ? void 0 : attr.toLowerCase() === \"true\";\n  }\n  function isElementIgnoredForAria(element) {\n    return [\"STYLE\", \"SCRIPT\", \"NOSCRIPT\", \"TEMPLATE\"].includes(elementSafeTagName(element));\n  }\n  function isElementHiddenForAria(element) {\n    if (isElementIgnoredForAria(element))\n      return true;\n    const style = getElementComputedStyle(element);\n    const isSlot = element.nodeName === \"SLOT\";\n    if ((style == null ? void 0 : style.display) === \"contents\" && !isSlot) {\n      for (let child = element.firstChild; child; child = child.nextSibling) {\n        if (child.nodeType === 1 && !isElementHiddenForAria(child))\n          return false;\n        if (child.nodeType === 3 && isVisibleTextNode(child))\n          return false;\n      }\n      return true;\n    }\n    const isOptionInsideSelect = element.nodeName === \"OPTION\" && !!element.closest(\"select\");\n    if (!isOptionInsideSelect && !isSlot && !isElementStyleVisibilityVisible(element, style))\n      return true;\n    return belongsToDisplayNoneOrAriaHiddenOrNonSlotted(element);\n  }\n  function belongsToDisplayNoneOrAriaHiddenOrNonSlotted(element) {\n    let hidden = cacheIsHidden == null ? void 0 : cacheIsHidden.get(element);\n    if (hidden === void 0) {\n      hidden = false;\n      if (element.parentElement && element.parentElement.shadowRoot && !element.assignedSlot)\n        hidden = true;\n      if (!hidden) {\n        const style = getElementComputedStyle(element);\n        hidden = !style || style.display === \"none\" || getAriaBoolean(element.getAttribute(\"aria-hidden\")) === true;\n      }\n      if (!hidden) {\n        const parent = parentElementOrShadowHost(element);\n        if (parent)\n          hidden = belongsToDisplayNoneOrAriaHiddenOrNonSlotted(parent);\n      }\n      cacheIsHidden == null ? void 0 : cacheIsHidden.set(element, hidden);\n    }\n    return hidden;\n  }\n  function getIdRefs(element, ref) {\n    if (!ref)\n      return [];\n    const root = enclosingShadowRootOrDocument(element);\n    if (!root)\n      return [];\n    try {\n      const ids = ref.split(\" \").filter((id) => !!id);\n      const result = [];\n      for (const id of ids) {\n        const firstElement = root.querySelector(\"#\" + CSS.escape(id));\n        if (firstElement && !result.includes(firstElement))\n          result.push(firstElement);\n      }\n      return result;\n    } catch (e) {\n      return [];\n    }\n  }\n  function trimFlatString(s) {\n    return s.trim();\n  }\n  function asFlatString(s) {\n    return s.split(\"\\xA0\").map((chunk) => chunk.replace(/\\r\\n/g, \"\\n\").replace(/[\\u200b\\u00ad]/g, \"\").replace(/\\s\\s*/g, \" \")).join(\"\\xA0\").trim();\n  }\n  function queryInAriaOwned(element, selector) {\n    const result = [...element.querySelectorAll(selector)];\n    for (const owned of getIdRefs(element, element.getAttribute(\"aria-owns\"))) {\n      if (owned.matches(selector))\n        result.push(owned);\n      result.push(...owned.querySelectorAll(selector));\n    }\n    return result;\n  }\n  function getPseudoContent(element, pseudo) {\n    const cache = pseudo === \"::before\" ? cachePseudoContentBefore : cachePseudoContentAfter;\n    if (cache == null ? void 0 : cache.has(element))\n      return (cache == null ? void 0 : cache.get(element)) || \"\";\n    const pseudoStyle = getElementComputedStyle(element, pseudo);\n    const content = getPseudoContentImpl(element, pseudoStyle);\n    if (cache)\n      cache.set(element, content);\n    return content;\n  }\n  function getPseudoContentImpl(element, pseudoStyle) {\n    if (!pseudoStyle || pseudoStyle.display === \"none\" || pseudoStyle.visibility === \"hidden\")\n      return \"\";\n    const content = pseudoStyle.content;\n    let resolvedContent;\n    if (content[0] === \"'\" && content[content.length - 1] === \"'\" || content[0] === '\"' && content[content.length - 1] === '\"') {\n      resolvedContent = content.substring(1, content.length - 1);\n    } else if (content.startsWith(\"attr(\") && content.endsWith(\")\")) {\n      const attrName = content.substring(\"attr(\".length, content.length - 1).trim();\n      resolvedContent = element.getAttribute(attrName) || \"\";\n    }\n    if (resolvedContent !== void 0) {\n      const display = pseudoStyle.display || \"inline\";\n      if (display !== \"inline\")\n        return \" \" + resolvedContent + \" \";\n      return resolvedContent;\n    }\n    return \"\";\n  }\n  function getAriaLabelledByElements(element) {\n    const ref = element.getAttribute(\"aria-labelledby\");\n    if (ref === null)\n      return null;\n    const refs = getIdRefs(element, ref);\n    return refs.length ? refs : null;\n  }\n  function allowsNameFromContent(role, targetDescendant) {\n    const alwaysAllowsNameFromContent = [\"button\", \"cell\", \"checkbox\", \"columnheader\", \"gridcell\", \"heading\", \"link\", \"menuitem\", \"menuitemcheckbox\", \"menuitemradio\", \"option\", \"radio\", \"row\", \"rowheader\", \"switch\", \"tab\", \"tooltip\", \"treeitem\"].includes(role);\n    const descendantAllowsNameFromContent = targetDescendant && [\"\", \"caption\", \"code\", \"contentinfo\", \"definition\", \"deletion\", \"emphasis\", \"insertion\", \"list\", \"listitem\", \"mark\", \"none\", \"paragraph\", \"presentation\", \"region\", \"row\", \"rowgroup\", \"section\", \"strong\", \"subscript\", \"superscript\", \"table\", \"term\", \"time\"].includes(role);\n    return alwaysAllowsNameFromContent || descendantAllowsNameFromContent;\n  }\n  function getElementAccessibleName(element, includeHidden) {\n    const cache = includeHidden ? cacheAccessibleNameHidden : cacheAccessibleName;\n    let accessibleName = cache == null ? void 0 : cache.get(element);\n    if (accessibleName === void 0) {\n      accessibleName = \"\";\n      const elementProhibitsNaming = [\"caption\", \"code\", \"definition\", \"deletion\", \"emphasis\", \"generic\", \"insertion\", \"mark\", \"paragraph\", \"presentation\", \"strong\", \"subscript\", \"suggestion\", \"superscript\", \"term\", \"time\"].includes(getAriaRole(element) || \"\");\n      if (!elementProhibitsNaming) {\n        accessibleName = asFlatString(getTextAlternativeInternal(element, {\n          includeHidden,\n          visitedElements: new Set(),\n          embeddedInTargetElement: \"self\"\n        }));\n      }\n      cache == null ? void 0 : cache.set(element, accessibleName);\n    }\n    return accessibleName;\n  }\n  function getTextAlternativeInternal(element, options) {\n    var _a, _b, _c, _d;\n    if (options.visitedElements.has(element))\n      return \"\";\n    const childOptions = {\n      ...options,\n      embeddedInTargetElement: options.embeddedInTargetElement === \"self\" ? \"descendant\" : options.embeddedInTargetElement\n    };\n    if (!options.includeHidden) {\n      const isEmbeddedInHiddenReferenceTraversal = !!((_a = options.embeddedInLabelledBy) == null ? void 0 : _a.hidden) || !!((_b = options.embeddedInDescribedBy) == null ? void 0 : _b.hidden) || !!((_c = options.embeddedInNativeTextAlternative) == null ? void 0 : _c.hidden) || !!((_d = options.embeddedInLabel) == null ? void 0 : _d.hidden);\n      if (isElementIgnoredForAria(element) || !isEmbeddedInHiddenReferenceTraversal && isElementHiddenForAria(element)) {\n        options.visitedElements.add(element);\n        return \"\";\n      }\n    }\n    const labelledBy = getAriaLabelledByElements(element);\n    if (!options.embeddedInLabelledBy) {\n      const accessibleName = (labelledBy || []).map((ref) => getTextAlternativeInternal(ref, {\n        ...options,\n        embeddedInLabelledBy: { element: ref, hidden: isElementHiddenForAria(ref) },\n        embeddedInDescribedBy: void 0,\n        embeddedInTargetElement: void 0,\n        embeddedInLabel: void 0,\n        embeddedInNativeTextAlternative: void 0\n      })).join(\" \");\n      if (accessibleName)\n        return accessibleName;\n    }\n    const role = getAriaRole(element) || \"\";\n    const tagName = elementSafeTagName(element);\n    if (!!options.embeddedInLabel || !!options.embeddedInLabelledBy || options.embeddedInTargetElement === \"descendant\") {\n      const isOwnLabel = [...element.labels || []].includes(element);\n      const isOwnLabelledBy = (labelledBy || []).includes(element);\n      if (!isOwnLabel && !isOwnLabelledBy) {\n        if (role === \"textbox\") {\n          options.visitedElements.add(element);\n          if (tagName === \"INPUT\" || tagName === \"TEXTAREA\")\n            return element.value;\n          return element.textContent || \"\";\n        }\n        if ([\"combobox\", \"listbox\"].includes(role)) {\n          options.visitedElements.add(element);\n          let selectedOptions;\n          if (tagName === \"SELECT\") {\n            selectedOptions = [...element.selectedOptions];\n            if (!selectedOptions.length && element.options.length)\n              selectedOptions.push(element.options[0]);\n          } else {\n            const listbox = role === \"combobox\" ? queryInAriaOwned(element, \"*\").find((e) => getAriaRole(e) === \"listbox\") : element;\n            selectedOptions = listbox ? queryInAriaOwned(listbox, '[aria-selected=\"true\"]').filter((e) => getAriaRole(e) === \"option\") : [];\n          }\n          if (!selectedOptions.length && tagName === \"INPUT\") {\n            return element.value;\n          }\n          return selectedOptions.map((option) => getTextAlternativeInternal(option, childOptions)).join(\" \");\n        }\n        if ([\"progressbar\", \"scrollbar\", \"slider\", \"spinbutton\", \"meter\"].includes(role)) {\n          options.visitedElements.add(element);\n          if (element.hasAttribute(\"aria-valuetext\"))\n            return element.getAttribute(\"aria-valuetext\") || \"\";\n          if (element.hasAttribute(\"aria-valuenow\"))\n            return element.getAttribute(\"aria-valuenow\") || \"\";\n          return element.getAttribute(\"value\") || \"\";\n        }\n        if ([\"menu\"].includes(role)) {\n          options.visitedElements.add(element);\n          return \"\";\n        }\n      }\n    }\n    const ariaLabel = element.getAttribute(\"aria-label\") || \"\";\n    if (trimFlatString(ariaLabel)) {\n      options.visitedElements.add(element);\n      return ariaLabel;\n    }\n    if (![\"presentation\", \"none\"].includes(role)) {\n      if (tagName === \"INPUT\" && [\"button\", \"submit\", \"reset\"].includes(element.type)) {\n        options.visitedElements.add(element);\n        const value = element.value || \"\";\n        if (trimFlatString(value))\n          return value;\n        if (element.type === \"submit\")\n          return \"Submit\";\n        if (element.type === \"reset\")\n          return \"Reset\";\n        const title = element.getAttribute(\"title\") || \"\";\n        return title;\n      }\n      if (!getGlobalOptions().inputFileRoleTextbox && tagName === \"INPUT\" && element.type === \"file\") {\n        options.visitedElements.add(element);\n        const labels = element.labels || [];\n        if (labels.length && !options.embeddedInLabelledBy)\n          return getAccessibleNameFromAssociatedLabels(labels, options);\n        return \"Choose File\";\n      }\n      if (tagName === \"INPUT\" && element.type === \"image\") {\n        options.visitedElements.add(element);\n        const labels = element.labels || [];\n        if (labels.length && !options.embeddedInLabelledBy)\n          return getAccessibleNameFromAssociatedLabels(labels, options);\n        const alt = element.getAttribute(\"alt\") || \"\";\n        if (trimFlatString(alt))\n          return alt;\n        const title = element.getAttribute(\"title\") || \"\";\n        if (trimFlatString(title))\n          return title;\n        return \"Submit\";\n      }\n      if (!labelledBy && tagName === \"BUTTON\") {\n        options.visitedElements.add(element);\n        const labels = element.labels || [];\n        if (labels.length)\n          return getAccessibleNameFromAssociatedLabels(labels, options);\n      }\n      if (!labelledBy && tagName === \"OUTPUT\") {\n        options.visitedElements.add(element);\n        const labels = element.labels || [];\n        if (labels.length)\n          return getAccessibleNameFromAssociatedLabels(labels, options);\n        return element.getAttribute(\"title\") || \"\";\n      }\n      if (!labelledBy && (tagName === \"TEXTAREA\" || tagName === \"SELECT\" || tagName === \"INPUT\")) {\n        options.visitedElements.add(element);\n        const labels = element.labels || [];\n        if (labels.length)\n          return getAccessibleNameFromAssociatedLabels(labels, options);\n        const usePlaceholder = tagName === \"INPUT\" && [\"text\", \"password\", \"search\", \"tel\", \"email\", \"url\"].includes(element.type) || tagName === \"TEXTAREA\";\n        const placeholder = element.getAttribute(\"placeholder\") || \"\";\n        const title = element.getAttribute(\"title\") || \"\";\n        if (!usePlaceholder || title)\n          return title;\n        return placeholder;\n      }\n      if (!labelledBy && tagName === \"FIELDSET\") {\n        options.visitedElements.add(element);\n        for (let child = element.firstElementChild; child; child = child.nextElementSibling) {\n          if (elementSafeTagName(child) === \"LEGEND\") {\n            return getTextAlternativeInternal(child, {\n              ...childOptions,\n              embeddedInNativeTextAlternative: { element: child, hidden: isElementHiddenForAria(child) }\n            });\n          }\n        }\n        const title = element.getAttribute(\"title\") || \"\";\n        return title;\n      }\n      if (!labelledBy && tagName === \"FIGURE\") {\n        options.visitedElements.add(element);\n        for (let child = element.firstElementChild; child; child = child.nextElementSibling) {\n          if (elementSafeTagName(child) === \"FIGCAPTION\") {\n            return getTextAlternativeInternal(child, {\n              ...childOptions,\n              embeddedInNativeTextAlternative: { element: child, hidden: isElementHiddenForAria(child) }\n            });\n          }\n        }\n        const title = element.getAttribute(\"title\") || \"\";\n        return title;\n      }\n      if (tagName === \"IMG\") {\n        options.visitedElements.add(element);\n        const alt = element.getAttribute(\"alt\") || \"\";\n        if (trimFlatString(alt))\n          return alt;\n        const title = element.getAttribute(\"title\") || \"\";\n        return title;\n      }\n      if (tagName === \"TABLE\") {\n        options.visitedElements.add(element);\n        for (let child = element.firstElementChild; child; child = child.nextElementSibling) {\n          if (elementSafeTagName(child) === \"CAPTION\") {\n            return getTextAlternativeInternal(child, {\n              ...childOptions,\n              embeddedInNativeTextAlternative: { element: child, hidden: isElementHiddenForAria(child) }\n            });\n          }\n        }\n        const summary = element.getAttribute(\"summary\") || \"\";\n        if (summary)\n          return summary;\n      }\n      if (tagName === \"AREA\") {\n        options.visitedElements.add(element);\n        const alt = element.getAttribute(\"alt\") || \"\";\n        if (trimFlatString(alt))\n          return alt;\n        const title = element.getAttribute(\"title\") || \"\";\n        return title;\n      }\n      if (tagName === \"SVG\" || element.ownerSVGElement) {\n        options.visitedElements.add(element);\n        for (let child = element.firstElementChild; child; child = child.nextElementSibling) {\n          if (elementSafeTagName(child) === \"TITLE\" && child.ownerSVGElement) {\n            return getTextAlternativeInternal(child, {\n              ...childOptions,\n              embeddedInLabelledBy: { element: child, hidden: isElementHiddenForAria(child) }\n            });\n          }\n        }\n      }\n      if (element.ownerSVGElement && tagName === \"A\") {\n        const title = element.getAttribute(\"xlink:title\") || \"\";\n        if (trimFlatString(title)) {\n          options.visitedElements.add(element);\n          return title;\n        }\n      }\n    }\n    const shouldNameFromContentForSummary = tagName === \"SUMMARY\" && ![\"presentation\", \"none\"].includes(role);\n    if (allowsNameFromContent(role, options.embeddedInTargetElement === \"descendant\") || shouldNameFromContentForSummary || !!options.embeddedInLabelledBy || !!options.embeddedInDescribedBy || !!options.embeddedInLabel || !!options.embeddedInNativeTextAlternative) {\n      options.visitedElements.add(element);\n      const accessibleName = innerAccumulatedElementText(element, childOptions);\n      const maybeTrimmedAccessibleName = options.embeddedInTargetElement === \"self\" ? trimFlatString(accessibleName) : accessibleName;\n      if (maybeTrimmedAccessibleName)\n        return accessibleName;\n    }\n    if (![\"presentation\", \"none\"].includes(role) || tagName === \"IFRAME\") {\n      options.visitedElements.add(element);\n      const title = element.getAttribute(\"title\") || \"\";\n      if (trimFlatString(title))\n        return title;\n    }\n    options.visitedElements.add(element);\n    return \"\";\n  }\n  function innerAccumulatedElementText(element, options) {\n    const tokens = [];\n    const visit = (node, skipSlotted) => {\n      var _a;\n      if (skipSlotted && node.assignedSlot)\n        return;\n      if (node.nodeType === 1) {\n        const display = ((_a = getElementComputedStyle(node)) == null ? void 0 : _a.display) || \"inline\";\n        let token = getTextAlternativeInternal(node, options);\n        if (display !== \"inline\" || node.nodeName === \"BR\")\n          token = \" \" + token + \" \";\n        tokens.push(token);\n      } else if (node.nodeType === 3) {\n        tokens.push(node.textContent || \"\");\n      }\n    };\n    tokens.push(getPseudoContent(element, \"::before\"));\n    const assignedNodes = element.nodeName === \"SLOT\" ? element.assignedNodes() : [];\n    if (assignedNodes.length) {\n      for (const child of assignedNodes)\n        visit(child, false);\n    } else {\n      for (let child = element.firstChild; child; child = child.nextSibling)\n        visit(child, true);\n      if (element.shadowRoot) {\n        for (let child = element.shadowRoot.firstChild; child; child = child.nextSibling)\n          visit(child, true);\n      }\n      for (const owned of getIdRefs(element, element.getAttribute(\"aria-owns\")))\n        visit(owned, true);\n    }\n    tokens.push(getPseudoContent(element, \"::after\"));\n    return tokens.join(\"\");\n  }\n  var kAriaSelectedRoles = [\"gridcell\", \"option\", \"row\", \"tab\", \"rowheader\", \"columnheader\", \"treeitem\"];\n  function getAriaSelected(element) {\n    if (elementSafeTagName(element) === \"OPTION\")\n      return element.selected;\n    if (kAriaSelectedRoles.includes(getAriaRole(element) || \"\"))\n      return getAriaBoolean(element.getAttribute(\"aria-selected\")) === true;\n    return false;\n  }\n  var kAriaCheckedRoles = [\"checkbox\", \"menuitemcheckbox\", \"option\", \"radio\", \"switch\", \"menuitemradio\", \"treeitem\"];\n  function getAriaChecked(element) {\n    const result = getChecked(element, true);\n    return result === \"error\" ? false : result;\n  }\n  function getChecked(element, allowMixed) {\n    const tagName = elementSafeTagName(element);\n    if (allowMixed && tagName === \"INPUT\" && element.indeterminate)\n      return \"mixed\";\n    if (tagName === \"INPUT\" && [\"checkbox\", \"radio\"].includes(element.type))\n      return element.checked;\n    if (kAriaCheckedRoles.includes(getAriaRole(element) || \"\")) {\n      const checked = element.getAttribute(\"aria-checked\");\n      if (checked === \"true\")\n        return true;\n      if (allowMixed && checked === \"mixed\")\n        return \"mixed\";\n      return false;\n    }\n    return \"error\";\n  }\n  var kAriaPressedRoles = [\"button\"];\n  function getAriaPressed(element) {\n    if (kAriaPressedRoles.includes(getAriaRole(element) || \"\")) {\n      const pressed = element.getAttribute(\"aria-pressed\");\n      if (pressed === \"true\")\n        return true;\n      if (pressed === \"mixed\")\n        return \"mixed\";\n    }\n    return false;\n  }\n  var kAriaExpandedRoles = [\"application\", \"button\", \"checkbox\", \"combobox\", \"gridcell\", \"link\", \"listbox\", \"menuitem\", \"row\", \"rowheader\", \"tab\", \"treeitem\", \"columnheader\", \"menuitemcheckbox\", \"menuitemradio\", \"rowheader\", \"switch\"];\n  function getAriaExpanded(element) {\n    if (elementSafeTagName(element) === \"DETAILS\")\n      return element.open;\n    if (kAriaExpandedRoles.includes(getAriaRole(element) || \"\")) {\n      const expanded = element.getAttribute(\"aria-expanded\");\n      if (expanded === null)\n        return void 0;\n      if (expanded === \"true\")\n        return true;\n      return false;\n    }\n    return void 0;\n  }\n  var kAriaLevelRoles = [\"heading\", \"listitem\", \"row\", \"treeitem\"];\n  function getAriaLevel(element) {\n    const native = { \"H1\": 1, \"H2\": 2, \"H3\": 3, \"H4\": 4, \"H5\": 5, \"H6\": 6 }[elementSafeTagName(element)];\n    if (native)\n      return native;\n    if (kAriaLevelRoles.includes(getAriaRole(element) || \"\")) {\n      const attr = element.getAttribute(\"aria-level\");\n      const value = attr === null ? Number.NaN : Number(attr);\n      if (Number.isInteger(value) && value >= 1)\n        return value;\n    }\n    return 0;\n  }\n  var kAriaDisabledRoles = [\"application\", \"button\", \"composite\", \"gridcell\", \"group\", \"input\", \"link\", \"menuitem\", \"scrollbar\", \"separator\", \"tab\", \"checkbox\", \"columnheader\", \"combobox\", \"grid\", \"listbox\", \"menu\", \"menubar\", \"menuitemcheckbox\", \"menuitemradio\", \"option\", \"radio\", \"radiogroup\", \"row\", \"rowheader\", \"searchbox\", \"select\", \"slider\", \"spinbutton\", \"switch\", \"tablist\", \"textbox\", \"toolbar\", \"tree\", \"treegrid\", \"treeitem\"];\n  function getAriaDisabled(element) {\n    return isNativelyDisabled(element) || hasExplicitAriaDisabled(element);\n  }\n  function isNativelyDisabled(element) {\n    const isNativeFormControl = [\"BUTTON\", \"INPUT\", \"SELECT\", \"TEXTAREA\", \"OPTION\", \"OPTGROUP\"].includes(element.tagName);\n    return isNativeFormControl && (element.hasAttribute(\"disabled\") || belongsToDisabledFieldSet(element));\n  }\n  function belongsToDisabledFieldSet(element) {\n    const fieldSetElement = element == null ? void 0 : element.closest(\"FIELDSET[DISABLED]\");\n    if (!fieldSetElement)\n      return false;\n    const legendElement = fieldSetElement.querySelector(\":scope > LEGEND\");\n    return !legendElement || !legendElement.contains(element);\n  }\n  function hasExplicitAriaDisabled(element, isAncestor = false) {\n    if (!element)\n      return false;\n    if (isAncestor || kAriaDisabledRoles.includes(getAriaRole(element) || \"\")) {\n      const attribute = (element.getAttribute(\"aria-disabled\") || \"\").toLowerCase();\n      if (attribute === \"true\")\n        return true;\n      if (attribute === \"false\")\n        return false;\n      return hasExplicitAriaDisabled(parentElementOrShadowHost(element), true);\n    }\n    return false;\n  }\n  function getAccessibleNameFromAssociatedLabels(labels, options) {\n    return [...labels].map((label) => getTextAlternativeInternal(label, {\n      ...options,\n      embeddedInLabel: { element: label, hidden: isElementHiddenForAria(label) },\n      embeddedInNativeTextAlternative: void 0,\n      embeddedInLabelledBy: void 0,\n      embeddedInDescribedBy: void 0,\n      embeddedInTargetElement: void 0\n    })).filter((accessibleName) => !!accessibleName).join(\" \");\n  }\n  var cacheAccessibleName;\n  var cacheAccessibleNameHidden;\n  var cacheAccessibleDescription;\n  var cacheAccessibleDescriptionHidden;\n  var cacheAccessibleErrorMessage;\n  var cacheIsHidden;\n  var cachePseudoContentBefore;\n  var cachePseudoContentAfter;\n  var cachesCounter = 0;\n  function beginAriaCaches() {\n    ++cachesCounter;\n    cacheAccessibleName != null ? cacheAccessibleName : cacheAccessibleName = new Map();\n    cacheAccessibleNameHidden != null ? cacheAccessibleNameHidden : cacheAccessibleNameHidden = new Map();\n    cacheAccessibleDescription != null ? cacheAccessibleDescription : cacheAccessibleDescription = new Map();\n    cacheAccessibleDescriptionHidden != null ? cacheAccessibleDescriptionHidden : cacheAccessibleDescriptionHidden = new Map();\n    cacheAccessibleErrorMessage != null ? cacheAccessibleErrorMessage : cacheAccessibleErrorMessage = new Map();\n    cacheIsHidden != null ? cacheIsHidden : cacheIsHidden = new Map();\n    cachePseudoContentBefore != null ? cachePseudoContentBefore : cachePseudoContentBefore = new Map();\n    cachePseudoContentAfter != null ? cachePseudoContentAfter : cachePseudoContentAfter = new Map();\n  }\n  function endAriaCaches() {\n    if (!--cachesCounter) {\n      cacheAccessibleName = void 0;\n      cacheAccessibleNameHidden = void 0;\n      cacheAccessibleDescription = void 0;\n      cacheAccessibleDescriptionHidden = void 0;\n      cacheAccessibleErrorMessage = void 0;\n      cacheIsHidden = void 0;\n      cachePseudoContentBefore = void 0;\n      cachePseudoContentAfter = void 0;\n    }\n  }\n  var inputTypeToRole = {\n    \"button\": \"button\",\n    \"checkbox\": \"checkbox\",\n    \"image\": \"button\",\n    \"number\": \"spinbutton\",\n    \"radio\": \"radio\",\n    \"range\": \"slider\",\n    \"reset\": \"button\",\n    \"submit\": \"button\"\n  };\n\n  // src/browser/snapshot/yaml.ts\n  function yamlEscapeKeyIfNeeded(str) {\n    if (!yamlStringNeedsQuotes(str))\n      return str;\n    return `'` + str.replace(/'/g, `''`) + `'`;\n  }\n  function yamlEscapeValueIfNeeded(str) {\n    if (!yamlStringNeedsQuotes(str))\n      return str;\n    return '\"' + str.replace(/[\\\\\"\\x00-\\x1f\\x7f-\\x9f]/g, (c) => {\n      switch (c) {\n        case \"\\\\\":\n          return \"\\\\\\\\\";\n        case '\"':\n          return '\\\\\"';\n        case \"\\b\":\n          return \"\\\\b\";\n        case \"\\f\":\n          return \"\\\\f\";\n        case \"\\n\":\n          return \"\\\\n\";\n        case \"\\r\":\n          return \"\\\\r\";\n        case \"\t\":\n          return \"\\\\t\";\n        default:\n          const code = c.charCodeAt(0);\n          return \"\\\\x\" + code.toString(16).padStart(2, \"0\");\n      }\n    }) + '\"';\n  }\n  function yamlStringNeedsQuotes(str) {\n    if (str.length === 0)\n      return true;\n    if (/^\\s|\\s$/.test(str))\n      return true;\n    if (/[\\x00-\\x08\\x0b\\x0c\\x0e-\\x1f\\x7f-\\x9f]/.test(str))\n      return true;\n    if (/^-/.test(str))\n      return true;\n    if (/[\\n:](\\s|$)/.test(str))\n      return true;\n    if (/\\s#/.test(str))\n      return true;\n    if (/[\\n\\r]/.test(str))\n      return true;\n    if (/^[&*\\],?!>|@\"'#%]/.test(str))\n      return true;\n    if (/[{}`]/.test(str))\n      return true;\n    if (/^\\[/.test(str))\n      return true;\n    if (!isNaN(Number(str)) || [\"y\", \"n\", \"yes\", \"no\", \"true\", \"false\", \"on\", \"off\", \"null\"].includes(str.toLowerCase()))\n      return true;\n    return false;\n  }\n\n  // src/browser/snapshot/ariaSnapshot.ts\n  function generateAriaTree(rootElement, generation) {\n    const visited = new Set();\n    const snapshot = {\n      root: { role: \"fragment\", name: \"\", children: [], element: rootElement, props: {} },\n      elements: new Map(),\n      generation,\n      ids: new Map()\n    };\n    const addElement = (element) => {\n      const id = snapshot.elements.size + 1;\n      snapshot.elements.set(id, element);\n      snapshot.ids.set(element, id);\n    };\n    addElement(rootElement);\n    const visit = (ariaNode, node) => {\n      if (visited.has(node))\n        return;\n      visited.add(node);\n      if (node.nodeType === Node.TEXT_NODE && node.nodeValue) {\n        const text = node.nodeValue;\n        if (ariaNode.role !== \"textbox\" && text)\n          ariaNode.children.push(node.nodeValue || \"\");\n        return;\n      }\n      if (node.nodeType !== Node.ELEMENT_NODE)\n        return;\n      const element = node;\n      if (isElementHiddenForAria(element))\n        return;\n      const ariaChildren = [];\n      if (element.hasAttribute(\"aria-owns\")) {\n        const ids = element.getAttribute(\"aria-owns\").split(/\\s+/);\n        for (const id of ids) {\n          const ownedElement = rootElement.ownerDocument.getElementById(id);\n          if (ownedElement)\n            ariaChildren.push(ownedElement);\n        }\n      }\n      addElement(element);\n      const childAriaNode = toAriaNode(element);\n      if (childAriaNode)\n        ariaNode.children.push(childAriaNode);\n      processElement(childAriaNode || ariaNode, element, ariaChildren);\n    };\n    function processElement(ariaNode, element, ariaChildren = []) {\n      var _a;\n      const display = ((_a = getElementComputedStyle(element)) == null ? void 0 : _a.display) || \"inline\";\n      const treatAsBlock = display !== \"inline\" || element.nodeName === \"BR\" ? \" \" : \"\";\n      if (treatAsBlock)\n        ariaNode.children.push(treatAsBlock);\n      ariaNode.children.push(getPseudoContent(element, \"::before\"));\n      const assignedNodes = element.nodeName === \"SLOT\" ? element.assignedNodes() : [];\n      if (assignedNodes.length) {\n        for (const child of assignedNodes)\n          visit(ariaNode, child);\n      } else {\n        for (let child = element.firstChild; child; child = child.nextSibling) {\n          if (!child.assignedSlot)\n            visit(ariaNode, child);\n        }\n        if (element.shadowRoot) {\n          for (let child = element.shadowRoot.firstChild; child; child = child.nextSibling)\n            visit(ariaNode, child);\n        }\n      }\n      for (const child of ariaChildren)\n        visit(ariaNode, child);\n      ariaNode.children.push(getPseudoContent(element, \"::after\"));\n      if (treatAsBlock)\n        ariaNode.children.push(treatAsBlock);\n      if (ariaNode.children.length === 1 && ariaNode.name === ariaNode.children[0])\n        ariaNode.children = [];\n      if (ariaNode.role === \"link\" && element.hasAttribute(\"href\")) {\n        const href = element.getAttribute(\"href\");\n        ariaNode.props[\"url\"] = href;\n      }\n    }\n    beginAriaCaches();\n    try {\n      visit(snapshot.root, rootElement);\n    } finally {\n      endAriaCaches();\n    }\n    normalizeStringChildren(snapshot.root);\n    return snapshot;\n  }\n  function toAriaNode(element) {\n    if (element.nodeName === \"IFRAME\")\n      return { role: \"iframe\", name: \"\", children: [], props: {}, element };\n    const role = getAriaRole(element);\n    if (!role || role === \"presentation\" || role === \"none\")\n      return null;\n    const name = normalizeWhiteSpace(getElementAccessibleName(element, false) || \"\");\n    const result = { role, name, children: [], props: {}, element };\n    if (kAriaCheckedRoles.includes(role))\n      result.checked = getAriaChecked(element);\n    if (kAriaDisabledRoles.includes(role))\n      result.disabled = getAriaDisabled(element);\n    if (kAriaExpandedRoles.includes(role))\n      result.expanded = getAriaExpanded(element);\n    if (kAriaLevelRoles.includes(role))\n      result.level = getAriaLevel(element);\n    if (kAriaPressedRoles.includes(role))\n      result.pressed = getAriaPressed(element);\n    if (kAriaSelectedRoles.includes(role))\n      result.selected = getAriaSelected(element);\n    if (element instanceof HTMLInputElement || element instanceof HTMLTextAreaElement) {\n      if (element.type !== \"checkbox\" && element.type !== \"radio\" && (element.type !== \"file\" || getGlobalOptions().inputFileRoleTextbox))\n        result.children = [element.value];\n    }\n    return result;\n  }\n  function normalizeStringChildren(rootA11yNode) {\n    const flushChildren = (buffer, normalizedChildren) => {\n      if (!buffer.length)\n        return;\n      const text = normalizeWhiteSpace(buffer.join(\"\"));\n      if (text)\n        normalizedChildren.push(text);\n      buffer.length = 0;\n    };\n    const visit = (ariaNode) => {\n      const normalizedChildren = [];\n      const buffer = [];\n      for (const child of ariaNode.children || []) {\n        if (typeof child === \"string\") {\n          buffer.push(child);\n        } else {\n          flushChildren(buffer, normalizedChildren);\n          visit(child);\n          normalizedChildren.push(child);\n        }\n      }\n      flushChildren(buffer, normalizedChildren);\n      ariaNode.children = normalizedChildren.length ? normalizedChildren : [];\n      if (ariaNode.children.length === 1 && ariaNode.children[0] === ariaNode.name)\n        ariaNode.children = [];\n    };\n    visit(rootA11yNode);\n  }\n  function renderAriaTree(ariaSnapshot, options) {\n    const lines = [];\n    const includeText = (options == null ? void 0 : options.mode) === \"regex\" ? textContributesInfo : () => true;\n    const renderString = (options == null ? void 0 : options.mode) === \"regex\" ? convertToBestGuessRegex : (str) => str;\n    const visit = (ariaNode2, parentAriaNode, indent) => {\n      if (typeof ariaNode2 === \"string\") {\n        if (parentAriaNode && !includeText(parentAriaNode, ariaNode2))\n          return;\n        const text = yamlEscapeValueIfNeeded(renderString(ariaNode2));\n        if (text)\n          lines.push(indent + \"- text: \" + text);\n        return;\n      }\n      let key = ariaNode2.role;\n      if (ariaNode2.name && ariaNode2.name.length <= 900) {\n        const name = renderString(ariaNode2.name);\n        if (name) {\n          const stringifiedName = name.startsWith(\"/\") && name.endsWith(\"/\") ? name : JSON.stringify(name);\n          key += \" \" + stringifiedName;\n        }\n      }\n      if (ariaNode2.checked === \"mixed\")\n        key += ` [checked=mixed]`;\n      if (ariaNode2.checked === true)\n        key += ` [checked]`;\n      if (ariaNode2.disabled)\n        key += ` [disabled]`;\n      if (ariaNode2.expanded)\n        key += ` [expanded]`;\n      if (ariaNode2.level)\n        key += ` [level=${ariaNode2.level}]`;\n      if (ariaNode2.pressed === \"mixed\")\n        key += ` [pressed=mixed]`;\n      if (ariaNode2.pressed === true)\n        key += ` [pressed]`;\n      if (ariaNode2.selected === true)\n        key += ` [selected]`;\n      if (options == null ? void 0 : options.ref) {\n        const id = ariaSnapshot.ids.get(ariaNode2.element);\n        if (id)\n          key += ` [ref=s${ariaSnapshot.generation}e${id}]`;\n      }\n      const escapedKey = indent + \"- \" + yamlEscapeKeyIfNeeded(key);\n      const hasProps = !!Object.keys(ariaNode2.props).length;\n      if (!ariaNode2.children.length && !hasProps) {\n        lines.push(escapedKey);\n      } else if (ariaNode2.children.length === 1 && typeof ariaNode2.children[0] === \"string\" && !hasProps) {\n        const text = includeText(ariaNode2, ariaNode2.children[0]) ? renderString(ariaNode2.children[0]) : null;\n        if (text)\n          lines.push(escapedKey + \": \" + yamlEscapeValueIfNeeded(text));\n        else\n          lines.push(escapedKey);\n      } else {\n        lines.push(escapedKey + \":\");\n        for (const [name, value] of Object.entries(ariaNode2.props))\n          lines.push(indent + \"  - /\" + name + \": \" + yamlEscapeValueIfNeeded(value));\n        for (const child of ariaNode2.children || [])\n          visit(child, ariaNode2, indent + \"  \");\n      }\n    };\n    const ariaNode = ariaSnapshot.root;\n    if (ariaNode.role === \"fragment\") {\n      for (const child of ariaNode.children || [])\n        visit(child, ariaNode, \"\");\n    } else {\n      visit(ariaNode, null, \"\");\n    }\n    return lines.join(\"\\n\");\n  }\n  function convertToBestGuessRegex(text) {\n    const dynamicContent = [\n      // 2mb\n      { regex: /\\b[\\d,.]+[bkmBKM]+\\b/, replacement: \"[\\\\d,.]+[bkmBKM]+\" },\n      // 2ms, 20s\n      { regex: /\\b\\d+[hmsp]+\\b/, replacement: \"\\\\d+[hmsp]+\" },\n      { regex: /\\b[\\d,.]+[hmsp]+\\b/, replacement: \"[\\\\d,.]+[hmsp]+\" },\n      // Do not replace single digits with regex by default.\n      // 2+ digits: [Issue 22, 22.3, 2.33, 2,333]\n      { regex: /\\b\\d+,\\d+\\b/, replacement: \"\\\\d+,\\\\d+\" },\n      { regex: /\\b\\d+\\.\\d{2,}\\b/, replacement: \"\\\\d+\\\\.\\\\d+\" },\n      { regex: /\\b\\d{2,}\\.\\d+\\b/, replacement: \"\\\\d+\\\\.\\\\d+\" },\n      { regex: /\\b\\d{2,}\\b/, replacement: \"\\\\d+\" }\n    ];\n    let pattern = \"\";\n    let lastIndex = 0;\n    const combinedRegex = new RegExp(dynamicContent.map((r) => \"(\" + r.regex.source + \")\").join(\"|\"), \"g\");\n    text.replace(combinedRegex, (match, ...args) => {\n      const offset = args[args.length - 2];\n      const groups = args.slice(0, -2);\n      pattern += escapeRegExp(text.slice(lastIndex, offset));\n      for (let i = 0; i < groups.length; i++) {\n        if (groups[i]) {\n          const { replacement } = dynamicContent[i];\n          pattern += replacement;\n          break;\n        }\n      }\n      lastIndex = offset + match.length;\n      return match;\n    });\n    if (!pattern)\n      return text;\n    pattern += escapeRegExp(text.slice(lastIndex));\n    return String(new RegExp(pattern));\n  }\n  function textContributesInfo(node, text) {\n    if (!text.length)\n      return false;\n    if (!node.name)\n      return true;\n    if (node.name.length > text.length)\n      return false;\n    const substr = text.length <= 200 && node.name.length <= 200 ? longestCommonSubstring(text, node.name) : \"\";\n    let filtered = text;\n    while (substr && filtered.includes(substr))\n      filtered = filtered.replace(substr, \"\");\n    return filtered.trim().length / text.length > 0.1;\n  }\n\n  // src/browser/snapshot/injectedScript.ts\n  var InjectedScript = class {\n    constructor(window2, isUnderTest) {\n      __publicField(this, \"utils\", {\n        builtins: builtins()\n      });\n      __publicField(this, \"_lastAriaSnapshot\");\n      __publicField(this, \"window\");\n      __publicField(this, \"document\");\n      this.window = window2;\n      this.document = window2.document;\n      this.utils.builtins = builtins(window2);\n      if (isUnderTest)\n        this.window.__injectedScript = this;\n    }\n    ariaSnapshot(node, options) {\n      var _a;\n      if (node.nodeType !== Node.ELEMENT_NODE)\n        throw this.createStacklessError(\"Can only capture aria snapshot of Element nodes.\");\n      const generation = (((_a = this._lastAriaSnapshot) == null ? void 0 : _a.generation) || 0) + 1;\n      this._lastAriaSnapshot = generateAriaTree(node, generation);\n      return renderAriaTree(this._lastAriaSnapshot, options);\n    }\n    ariaSnapshotElement(snapshot, elementId) {\n      return snapshot.elements.get(elementId) || null;\n    }\n    createStacklessError(message) {\n      const error = new Error(message);\n      delete error.stack;\n      return error;\n    }\n  };\n  function createAriaSnapshot(element, options) {\n    const injectedScript = new InjectedScript(window, false);\n    return injectedScript.ariaSnapshot(element, options);\n  }\n  if (typeof window !== \"undefined\") {\n    window.InjectedScript = InjectedScript;\n    window.createAriaSnapshot = createAriaSnapshot;\n  }\n  return __toCommonJS(injectedScript_exports);\n})();\n";
